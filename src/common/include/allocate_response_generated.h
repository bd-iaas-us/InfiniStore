// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ALLOCATERESPONSE_H_
#define FLATBUFFERS_GENERATED_ALLOCATERESPONSE_H_

#include "flatbuffers/flatbuffers.h"

struct RemoteBlock;

struct RdmaAllocateResponse;
struct RdmaAllocateResponseBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) RemoteBlock FLATBUFFERS_FINAL_CLASS {
   private:
    uint32_t rkey_;
    int32_t padding0__;
    uint64_t remote_addr_;

   public:
    RemoteBlock() : rkey_(0), padding0__(0), remote_addr_(0) { (void)padding0__; }
    RemoteBlock(uint32_t _rkey, uint64_t _remote_addr)
        : rkey_(flatbuffers::EndianScalar(_rkey)),
          padding0__(0),
          remote_addr_(flatbuffers::EndianScalar(_remote_addr)) {}
    uint32_t rkey() const { return flatbuffers::EndianScalar(rkey_); }
    uint64_t remote_addr() const { return flatbuffers::EndianScalar(remote_addr_); }
};
FLATBUFFERS_STRUCT_END(RemoteBlock, 16);

struct RdmaAllocateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef RdmaAllocateResponseBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_BLOCKS = 4 };
    const flatbuffers::Vector<const RemoteBlock *> *blocks() const {
        return GetPointer<const flatbuffers::Vector<const RemoteBlock *> *>(VT_BLOCKS);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_BLOCKS) &&
               verifier.VerifyVector(blocks()) && verifier.EndTable();
    }
};

struct RdmaAllocateResponseBuilder {
    typedef RdmaAllocateResponse Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_blocks(flatbuffers::Offset<flatbuffers::Vector<const RemoteBlock *>> blocks) {
        fbb_.AddOffset(RdmaAllocateResponse::VT_BLOCKS, blocks);
    }
    explicit RdmaAllocateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    flatbuffers::Offset<RdmaAllocateResponse> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<RdmaAllocateResponse>(end);
        return o;
    }
};

inline flatbuffers::Offset<RdmaAllocateResponse> CreateRdmaAllocateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const RemoteBlock *>> blocks = 0) {
    RdmaAllocateResponseBuilder builder_(_fbb);
    builder_.add_blocks(blocks);
    return builder_.Finish();
}

inline flatbuffers::Offset<RdmaAllocateResponse> CreateRdmaAllocateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<RemoteBlock> *blocks = nullptr) {
    auto blocks__ = blocks ? _fbb.CreateVectorOfStructs<RemoteBlock>(*blocks) : 0;
    return CreateRdmaAllocateResponse(_fbb, blocks__);
}

inline const RdmaAllocateResponse *GetRdmaAllocateResponse(const void *buf) {
    return flatbuffers::GetRoot<RdmaAllocateResponse>(buf);
}

inline const RdmaAllocateResponse *GetSizePrefixedRdmaAllocateResponse(const void *buf) {
    return flatbuffers::GetSizePrefixedRoot<RdmaAllocateResponse>(buf);
}

inline bool VerifyRdmaAllocateResponseBuffer(flatbuffers::Verifier &verifier) {
    return verifier.VerifyBuffer<RdmaAllocateResponse>(nullptr);
}

inline bool VerifySizePrefixedRdmaAllocateResponseBuffer(flatbuffers::Verifier &verifier) {
    return verifier.VerifySizePrefixedBuffer<RdmaAllocateResponse>(nullptr);
}

inline void FinishRdmaAllocateResponseBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                             flatbuffers::Offset<RdmaAllocateResponse> root) {
    fbb.Finish(root);
}

inline void FinishSizePrefixedRdmaAllocateResponseBuffer(
    flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<RdmaAllocateResponse> root) {
    fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_ALLOCATERESPONSE_H_
